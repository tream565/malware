# malware
```
for root, dirs, paths in os.walk(args.target_directory):      
       for path in paths:
            full_path = os.path.join(root,path)
            malware_paths.append(full_path)
```
搜索指定路徑將APT1家族惡意程式放進malware_paths

```
malware_paths = filter(pecheck, malware_paths)

def pecheck(fullpath):
    return open(fullpath).read(2) == "MZ"
```
用filter功能以自定義函數pecheck做為條件濾出惡意程式文件裡有MZ兩字的惡意程式
```
 for path in malware_paths:
        attributes = getstrings(path)
        print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
        malware_attributes[path] = attributes
        
        graph.add_node(path,label=os.path.split(path)[-1][:10])
        
 def getstrings(fullpath):
    strings = os.popen("strings '{0}'".format(fullpath)).read()
    strings = set(strings.split("\n"))
    return strings
```
用getstrings函數讀取惡意程式文件的集合並將其儲存進attributes，並將每個惡意程式畫成節點

```
for malware1,malware2 in itertools.combinations(malware_paths,2):
        jaccard_index = jaccard(malware_attributes[malware1],malware_attributes[malware2])

        if jaccard_index > args.threshold:
            print malware1,malware2,jaccard_index
            graph.add_edge(malware1,malware2,penwidth=1+(jaccard_index-args.threshold)*10)
```
用itertools.combinations把2個不重複的malware_paths放進malware1及malware2，再用jaccard函數去算malware1及malware2的malware_attributes裡的惡意程式文件的相似度
如果大於輸入的數值就將兩者連線，線的粗度由兩者相似度減掉輸入數值在乘10，因此越相似就越粗。
